{
	"compiler": {
		"version": "0.8.27+commit.40a35a09"
	},
	"language": "Solidity",
	"output": {
		"abi": [
			{
				"inputs": [],
				"name": "ReentrancyGuardReentrantCall",
				"type": "error"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"internalType": "address",
						"name": "provider",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "address",
						"name": "tokenA",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "address",
						"name": "tokenB",
						"type": "address"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "amountA",
						"type": "uint256"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "amountB",
						"type": "uint256"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "liquidityMinted",
						"type": "uint256"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "timestamp",
						"type": "uint256"
					}
				],
				"name": "LiquidityAdded",
				"type": "event"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"internalType": "address",
						"name": "provider",
						"type": "address"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "amountA",
						"type": "uint256"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "amountB",
						"type": "uint256"
					}
				],
				"name": "LiquidityRemoved",
				"type": "event"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"internalType": "address",
						"name": "swapper",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "address",
						"name": "tokenIn",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "address",
						"name": "tokenOut",
						"type": "address"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "amountIn",
						"type": "uint256"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "amountOut",
						"type": "uint256"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "timestamp",
						"type": "uint256"
					}
				],
				"name": "TokensSwapped",
				"type": "event"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "tokenA",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "tokenB",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "amountADesired",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountBDesired",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountAMin",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountBMin",
						"type": "uint256"
					},
					{
						"internalType": "address",
						"name": "to",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "deadline",
						"type": "uint256"
					}
				],
				"name": "addLiquidity",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "amountA",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountB",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "liquidity",
						"type": "uint256"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "amountIn",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "reserveIn",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "reserveOut",
						"type": "uint256"
					}
				],
				"name": "getAmountOut",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "amountOut",
						"type": "uint256"
					}
				],
				"stateMutability": "pure",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "tokenA",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "tokenB",
						"type": "address"
					}
				],
				"name": "getPrice",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "price",
						"type": "uint256"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "tokenA",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "tokenB",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "liquidity",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountAMin",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountBMin",
						"type": "uint256"
					},
					{
						"internalType": "address",
						"name": "to",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "deadline",
						"type": "uint256"
					}
				],
				"name": "removeLiquidity",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "amountA",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountB",
						"type": "uint256"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "amountIn",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountOutMin",
						"type": "uint256"
					},
					{
						"internalType": "address[]",
						"name": "path",
						"type": "address[]"
					},
					{
						"internalType": "address",
						"name": "to",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "deadline",
						"type": "uint256"
					}
				],
				"name": "swapExactTokensForTokens",
				"outputs": [
					{
						"internalType": "uint256[]",
						"name": "amounts",
						"type": "uint256[]"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			}
		],
		"devdoc": {
			"details": "Contrato de intercambio descentralizado basico (similar a Uniswap V2) que permite a los usuarios agregar/remover liquidez e intercambiar tokens ERC-20, obtener precios y calcular cantidades a recibir. No depende directamente del protocolo Uniswap; implementa su propia logica de pool.",
			"errors": {
				"ReentrancyGuardReentrantCall()": [
					{
						"details": "Unauthorized reentrant call."
					}
				]
			},
			"kind": "dev",
			"methods": {
				"addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)": {
					"details": "Permite a los usuarios agregar liquidez a un pool de tokens ERC-20. Si es la primera liquidez, se inicializa el pool. De lo contrario, se calculan las cantidades optimas para mantener la proporcion existente.",
					"params": {
						"amountADesired": "La cantidad deseada de tokenA a depositar.",
						"amountAMin": "La cantidad minima de tokenA que debe aceptarse (proteccion contra slippage).",
						"amountBDesired": "La cantidad deseada de tokenB a depositar.",
						"amountBMin": "La cantidad minima de tokenB que debe aceptarse (proteccion contra slippage).",
						"deadline": "El tiempo limite para que la transaccion sea minada.",
						"to": "La direccion a la que se le asignara la liquidez aportada.",
						"tokenA": "La direccion del primer token a agregar.",
						"tokenB": "La direccion del segundo token a agregar."
					},
					"returns": {
						"amountA": "La cantidad real de tokenA transferida y utilizada.",
						"amountB": "La cantidad real de tokenB transferida y utilizada.",
						"liquidity": "La cantidad de liquidez registrada para el usuario."
					}
				},
				"getAmountOut(uint256,uint256,uint256)": {
					"details": "Calcula cuantos tokens de salida se recibiran para una cantidad dada de tokens de entrada, basado en las reservas actuales del pool. Utiliza la formula de producto constante (x * y = k) sin aplicar comisiones de swap. amountOut = (amountIn * reserveOut) / (reserveIn + amountIn)",
					"params": {
						"amountIn": "La cantidad del token de entrada.",
						"reserveIn": "La reserva del token de entrada en el pool.",
						"reserveOut": "La reserva del token de salida en el pool."
					},
					"returns": {
						"amountOut": "La cantidad de tokens de salida esperada."
					}
				},
				"getPrice(address,address)": {
					"details": "Devuelve el precio actual de un token en terminos de otro. El precio se escala por 1e18 para una mejor precision. Por ejemplo, si el precio de TokenB en TokenA es 0.5, se retornara 0.5 * 1e18.",
					"params": {
						"tokenA": "La direccion del primer token.",
						"tokenB": "La direccion del segundo token."
					},
					"returns": {
						"price": "El precio de tokenB en terminos de tokenA (o viceversa si tokenA > tokenB), escalado por 1e18."
					}
				},
				"removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)": {
					"details": "Permite a los usuarios retirar liquidez de un pool quemando sus tokens de liquidez (LP tokens). Los usuarios reciben una cantidad proporcional de los tokens subyacentes (tokenA y tokenB).",
					"params": {
						"amountAMin": "La cantidad minima de tokenA que debe recibirse (proteccion contra slippage).",
						"amountBMin": "La cantidad minima de tokenB que debe recibirse (proteccion contra slippage).",
						"deadline": "El tiempo limite para que la transaccion sea minada.",
						"liquidity": "La cantidad de tokens de liquidez (LP tokens) a quemar.",
						"to": "La direccion a la que se enviaran los tokens A y B retirados.",
						"tokenA": "La direccion del primer token en el par.",
						"tokenB": "La direccion del segundo token en el par."
					},
					"returns": {
						"amountA": "La cantidad real de tokenA retirada.",
						"amountB": "La cantidad real de tokenB retirada."
					}
				},
				"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)": {
					"details": "Permite a los usuarios intercambiar una cantidad exacta de un token (amountIn) por otro token, con una ruta de un solo salto. El `path` debe contener exactamente dos direcciones: [tokenEntrada, tokenSalida].",
					"params": {
						"amountIn": "La cantidad exacta del token de entrada a intercambiar.",
						"amountOutMin": "La cantidad minima del token de salida que debe recibirse (proteccion contra slippage).",
						"deadline": "El tiempo limite para que la transaccion sea minada.",
						"path": "Un array con las direcciones de los tokens en la ruta de intercambio (ej: [tokenA, tokenB]).",
						"to": "La direccion a la que se enviara el token de salida."
					},
					"returns": {
						"amounts": "Un array con la cantidad de entrada (amounts[0]) y la cantidad de salida (amounts[1])."
					}
				}
			},
			"title": "SimpleSwap",
			"version": 1
		},
		"userdoc": {
			"kind": "user",
			"methods": {},
			"version": 1
		}
	},
	"settings": {
		"compilationTarget": {
			"TP3_ACTUAL/SimpleSwap.sol": "SimpleSwap"
		},
		"evmVersion": "cancun",
		"libraries": {},
		"metadata": {
			"bytecodeHash": "ipfs"
		},
		"optimizer": {
			"enabled": false,
			"runs": 200
		},
		"remappings": []
	},
	"sources": {
		"@openzeppelin/contracts/token/ERC20/IERC20.sol": {
			"keccak256": "0xe06a3f08a987af6ad2e1c1e774405d4fe08f1694b67517438b467cecf0da0ef7",
			"license": "MIT",
			"urls": [
				"bzz-raw://df6f0c459663c9858b6cba2cda1d14a7d05a985bed6d2de72bd8e78c25ee79db",
				"dweb:/ipfs/QmeTTxZ7qVk9rjEv2R4CpCwdf8UMCcRqDNMvzNxHc3Fnn9"
			]
		},
		"@openzeppelin/contracts/utils/Panic.sol": {
			"keccak256": "0xf7fe324703a64fc51702311dc51562d5cb1497734f074e4f483bfb6717572d7a",
			"license": "MIT",
			"urls": [
				"bzz-raw://c6a5ff4f9fd8649b7ee20800b7fa387d3465bd77cf20c2d1068cd5c98e1ed57a",
				"dweb:/ipfs/QmVSaVJf9FXFhdYEYeCEfjMVHrxDh5qL4CGkxdMWpQCrqG"
			]
		},
		"@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
			"keccak256": "0x11a5a79827df29e915a12740caf62fe21ebe27c08c9ae3e09abe9ee3ba3866d3",
			"license": "MIT",
			"urls": [
				"bzz-raw://3cf0c69ab827e3251db9ee6a50647d62c90ba580a4d7bbff21f2bea39e7b2f4a",
				"dweb:/ipfs/QmZiKwtKU1SBX4RGfQtY7PZfiapbbu6SZ9vizGQD9UHjRA"
			]
		},
		"@openzeppelin/contracts/utils/math/Math.sol": {
			"keccak256": "0x1225214420c83ebcca88f2ae2b50f053aaa7df7bd684c3e878d334627f2edfc6",
			"license": "MIT",
			"urls": [
				"bzz-raw://6c5fab4970634f9ab9a620983dc1c8a30153981a0b1a521666e269d0a11399d3",
				"dweb:/ipfs/QmVRnBC575MESGkEHndjujtR7qub2FzU9RWy9eKLp4hPZB"
			]
		},
		"@openzeppelin/contracts/utils/math/SafeCast.sol": {
			"keccak256": "0x195533c86d0ef72bcc06456a4f66a9b941f38eb403739b00f21fd7c1abd1ae54",
			"license": "MIT",
			"urls": [
				"bzz-raw://b1d578337048cad08c1c03041cca5978eff5428aa130c781b271ad9e5566e1f8",
				"dweb:/ipfs/QmPFKL2r9CBsMwmUqqdcFPfHZB2qcs9g1HDrPxzWSxomvy"
			]
		},
		"TP3_ACTUAL/SimpleSwap.sol": {
			"keccak256": "0x825fdc3222dceb214624d3261c7981deaf6166b443382e73dfaf40a158cfb706",
			"license": "MIT",
			"urls": [
				"bzz-raw://ab14007f3d06f6b4e5e61faf483e01a5da31695e479280ad5b79936b539cab0d",
				"dweb:/ipfs/QmUgSq3jjezUFFma98op4hEhWxP9J1vxPQdxi6gAtigG1b"
			]
		}
	},
	"version": 1
}