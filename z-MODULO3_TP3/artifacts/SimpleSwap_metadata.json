{
	"compiler": {
		"version": "0.8.27+commit.40a35a09"
	},
	"language": "Solidity",
	"output": {
		"abi": [
			{
				"inputs": [],
				"name": "ReentrancyGuardReentrantCall",
				"type": "error"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"internalType": "address",
						"name": "provider",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "address",
						"name": "tokenA",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "address",
						"name": "tokenB",
						"type": "address"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "amountA",
						"type": "uint256"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "amountB",
						"type": "uint256"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "liquidityMinted",
						"type": "uint256"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "timestamp",
						"type": "uint256"
					}
				],
				"name": "LiquidityAdded",
				"type": "event"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"internalType": "address",
						"name": "provider",
						"type": "address"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "amountA",
						"type": "uint256"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "amountB",
						"type": "uint256"
					}
				],
				"name": "LiquidityRemoved",
				"type": "event"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"internalType": "address",
						"name": "swapper",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "address",
						"name": "tokenIn",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "address",
						"name": "tokenOut",
						"type": "address"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "amountIn",
						"type": "uint256"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "amountOut",
						"type": "uint256"
					},
					{
						"indexed": false,
						"internalType": "uint256",
						"name": "timestamp",
						"type": "uint256"
					}
				],
				"name": "TokensSwapped",
				"type": "event"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "tokenA",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "tokenB",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "amountADesired",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountBDesired",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountAMin",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountBMin",
						"type": "uint256"
					},
					{
						"internalType": "address",
						"name": "to",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "deadline",
						"type": "uint256"
					}
				],
				"name": "addLiquidity",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "amountA",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountB",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "liquidity",
						"type": "uint256"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "amountIn",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "reserveIn",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "reserveOut",
						"type": "uint256"
					}
				],
				"name": "getAmountOut",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "amountOut",
						"type": "uint256"
					}
				],
				"stateMutability": "pure",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "tokenA",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "tokenB",
						"type": "address"
					}
				],
				"name": "getPrice",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "price",
						"type": "uint256"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "tokenA",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "tokenB",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "liquidity",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountAMin",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountBMin",
						"type": "uint256"
					},
					{
						"internalType": "address",
						"name": "to",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "deadline",
						"type": "uint256"
					}
				],
				"name": "removeLiquidity",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "amountA",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountB",
						"type": "uint256"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "amountIn",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountOutMin",
						"type": "uint256"
					},
					{
						"internalType": "address[]",
						"name": "path",
						"type": "address[]"
					},
					{
						"internalType": "address",
						"name": "to",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "deadline",
						"type": "uint256"
					}
				],
				"name": "swapExactTokensForTokens",
				"outputs": [
					{
						"internalType": "uint256[]",
						"name": "amounts",
						"type": "uint256[]"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			}
		],
		"devdoc": {
			"details": "A basic decentralized exchange contract (similar to Uniswap V2) that allows users to add/remove liquidity, swap ERC-20 tokens, get prices, and calculate amounts to receive. It does not directly depend on the Uniswap protocol; it implements its own pool logic.",
			"errors": {
				"ReentrancyGuardReentrantCall()": [
					{
						"details": "Unauthorized reentrant call."
					}
				]
			},
			"events": {
				"LiquidityAdded(address,address,address,uint256,uint256,uint256,uint256)": {
					"details": "Emitted when liquidity is successfully added to a pool.",
					"params": {
						"amountA": "The actual amount of tokenA transferred to the pool.",
						"amountB": "The actual amount of tokenB transferred to the pool.",
						"liquidityMinted": "The amount of internal liquidity tokens minted for the provider.",
						"provider": "The address of the liquidity provider.",
						"timestamp": "The timestamp when the liquidity was added.",
						"tokenA": "The address of the first token in the pair.",
						"tokenB": "The address of the second token in the pair."
					}
				},
				"LiquidityRemoved(address,uint256,uint256)": {
					"details": "Emitted when liquidity is successfully removed from a pool.",
					"params": {
						"amountA": "The amount of tokenA withdrawn from the pool.",
						"amountB": "The amount of tokenB withdrawn from the pool.",
						"provider": "The address of the liquidity provider who removed liquidity."
					}
				},
				"TokensSwapped(address,address,address,uint256,uint256,uint256)": {
					"details": "Emitted when tokens are successfully swapped in a pool.",
					"params": {
						"amountIn": "The amount of `tokenIn` that was swapped.",
						"amountOut": "The amount of `tokenOut` that was received.",
						"swapper": "The address of the user who performed the swap.",
						"timestamp": "The timestamp when the swap occurred.",
						"tokenIn": "The address of the token that was sent into the pool.",
						"tokenOut": "The address of the token that was received from the pool."
					}
				}
			},
			"kind": "dev",
			"methods": {
				"addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)": {
					"details": "Allows users to add liquidity to an ERC-20 token pair pool. If it's the first liquidity provision, the pool is initialized. Otherwise, optimal amounts are calculated to maintain the existing ratio.",
					"params": {
						"amountADesired": "The desired amount of tokenA to deposit.",
						"amountAMin": "The minimum amount of tokenA that must be accepted (slippage protection).",
						"amountBDesired": "The desired amount of tokenB to deposit.",
						"amountBMin": "The minimum amount of tokenB that must be accepted (slippage protection).",
						"deadline": "The timestamp by which the transaction must be mined.",
						"to": "The address to which the minted liquidity tokens will be assigned.",
						"tokenA": "The address of the first token to add.",
						"tokenB": "The address of the second token to add."
					},
					"returns": {
						"amountA": "The actual amount of tokenA transferred and used.",
						"amountB": "The actual amount of tokenB transferred and used.",
						"liquidity": "The amount of internal liquidity tokens minted for the user."
					}
				},
				"getAmountOut(uint256,uint256,uint256)": {
					"details": "Calculates how many output tokens will be received for a given amount of input tokens, based on the current pool reserves. It uses the constant product formula (x * y = k) without applying any swap fees. The formula used is: `amountOut = (amountIn * reserveOut) / (reserveIn + amountIn)`.",
					"params": {
						"amountIn": "The amount of the input token.",
						"reserveIn": "The reserve of the input token in the pool.",
						"reserveOut": "The reserve of the output token in the pool."
					},
					"returns": {
						"amountOut": "The expected amount of output tokens."
					}
				},
				"getPrice(address,address)": {
					"details": "Returns the current price of one token in terms of another. The price is scaled by 1e18 for better precision (e.g., if TokenB's price in TokenA is 0.5, it returns 0.5 * 1e18). The price is calculated as (reserve of tokenB / reserve of tokenA) if A is token0 (the lower address). If B is token0, then it's (reserve of tokenA / reserve of tokenB).",
					"params": {
						"tokenA": "The address of the first token.",
						"tokenB": "The address of the second token."
					},
					"returns": {
						"price": "The price of tokenB in terms of tokenA (or vice versa if tokenA > tokenB), scaled by 1e18."
					}
				},
				"removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)": {
					"details": "Allows users to withdraw liquidity from a token pool by burning their liquidity tokens (LP tokens). Users receive a proportional amount of the underlying tokens (tokenA and tokenB) based on their burned liquidity.",
					"params": {
						"amountAMin": "The minimum amount of tokenA that must be received (slippage protection).",
						"amountBMin": "The minimum amount of tokenB that must be received (slippage protection).",
						"deadline": "The timestamp by which the transaction must be mined.",
						"liquidity": "The amount of liquidity tokens (LP tokens) to burn.",
						"to": "The address to which the withdrawn tokenA and tokenB will be sent.",
						"tokenA": "The address of the first token in the pair.",
						"tokenB": "The address of the second token in the pair."
					},
					"returns": {
						"amountA": "The actual amount of tokenA withdrawn.",
						"amountB": "The actual amount of tokenB withdrawn."
					}
				},
				"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)": {
					"details": "Allows users to swap an exact amount of an input token (`amountIn`) for another token, with a single-hop path. The `path` array must contain exactly two token addresses: [inputToken, outputToken].",
					"params": {
						"amountIn": "The exact amount of the input token to swap.",
						"amountOutMin": "The minimum amount of the output token that must be received (slippage protection).",
						"deadline": "The timestamp by which the transaction must be mined.",
						"path": "An array containing the addresses of the tokens in the swap path (e.g., [tokenA, tokenB]).",
						"to": "The address to which the output token will be sent."
					},
					"returns": {
						"amounts": "An array containing the input amount (amounts[0]) and the output amount (amounts[1])."
					}
				}
			},
			"stateVariables": {
				"pools": {
					"details": "Mapping from a unique pair hash (bytes32) to its corresponding Pool struct. The pair hash ensures that each token pair has a single unique pool, regardless of the order in which tokens are provided (TokenA, TokenB or TokenB, TokenA)."
				}
			},
			"title": "SimpleSwap",
			"version": 1
		},
		"userdoc": {
			"kind": "user",
			"methods": {},
			"version": 1
		}
	},
	"settings": {
		"compilationTarget": {
			"MODULO3_TP3/SimpleSwap.sol": "SimpleSwap"
		},
		"evmVersion": "cancun",
		"libraries": {},
		"metadata": {
			"bytecodeHash": "ipfs"
		},
		"optimizer": {
			"enabled": false,
			"runs": 200
		},
		"remappings": []
	},
	"sources": {
		"@openzeppelin/contracts/token/ERC20/IERC20.sol": {
			"keccak256": "0xe06a3f08a987af6ad2e1c1e774405d4fe08f1694b67517438b467cecf0da0ef7",
			"license": "MIT",
			"urls": [
				"bzz-raw://df6f0c459663c9858b6cba2cda1d14a7d05a985bed6d2de72bd8e78c25ee79db",
				"dweb:/ipfs/QmeTTxZ7qVk9rjEv2R4CpCwdf8UMCcRqDNMvzNxHc3Fnn9"
			]
		},
		"@openzeppelin/contracts/utils/Panic.sol": {
			"keccak256": "0xf7fe324703a64fc51702311dc51562d5cb1497734f074e4f483bfb6717572d7a",
			"license": "MIT",
			"urls": [
				"bzz-raw://c6a5ff4f9fd8649b7ee20800b7fa387d3465bd77cf20c2d1068cd5c98e1ed57a",
				"dweb:/ipfs/QmVSaVJf9FXFhdYEYeCEfjMVHrxDh5qL4CGkxdMWpQCrqG"
			]
		},
		"@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
			"keccak256": "0x11a5a79827df29e915a12740caf62fe21ebe27c08c9ae3e09abe9ee3ba3866d3",
			"license": "MIT",
			"urls": [
				"bzz-raw://3cf0c69ab827e3251db9ee6a50647d62c90ba580a4d7bbff21f2bea39e7b2f4a",
				"dweb:/ipfs/QmZiKwtKU1SBX4RGfQtY7PZfiapbbu6SZ9vizGQD9UHjRA"
			]
		},
		"@openzeppelin/contracts/utils/math/Math.sol": {
			"keccak256": "0x1225214420c83ebcca88f2ae2b50f053aaa7df7bd684c3e878d334627f2edfc6",
			"license": "MIT",
			"urls": [
				"bzz-raw://6c5fab4970634f9ab9a620983dc1c8a30153981a0b1a521666e269d0a11399d3",
				"dweb:/ipfs/QmVRnBC575MESGkEHndjujtR7qub2FzU9RWy9eKLp4hPZB"
			]
		},
		"@openzeppelin/contracts/utils/math/SafeCast.sol": {
			"keccak256": "0x195533c86d0ef72bcc06456a4f66a9b941f38eb403739b00f21fd7c1abd1ae54",
			"license": "MIT",
			"urls": [
				"bzz-raw://b1d578337048cad08c1c03041cca5978eff5428aa130c781b271ad9e5566e1f8",
				"dweb:/ipfs/QmPFKL2r9CBsMwmUqqdcFPfHZB2qcs9g1HDrPxzWSxomvy"
			]
		},
		"MODULO3_TP3/SimpleSwap.sol": {
			"keccak256": "0x20132acfed92a8c4824a6e91f62da7a3398e0d5f6c0f24773aa478c70b8af82d",
			"license": "MIT",
			"urls": [
				"bzz-raw://a15dd1568e45999ab143a26a39163e6405389f9085a8ce64efbb3abb80d4edd4",
				"dweb:/ipfs/QmafmA5SGFPpeswodTaHZBpMWdK8RbNvZCcC9a1zEKbG4W"
			]
		}
	},
	"version": 1
}