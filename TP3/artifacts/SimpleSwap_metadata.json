{
	"compiler": {
		"version": "0.8.30+commit.73712a01"
	},
	"language": "Solidity",
	"output": {
		"abi": [
			{
				"inputs": [],
				"name": "ReentrancyGuardReentrantCall",
				"type": "error"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "tokenA",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "tokenB",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "amountADesired",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountBDesired",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountAMin",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountBMin",
						"type": "uint256"
					},
					{
						"internalType": "address",
						"name": "to",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "deadline",
						"type": "uint256"
					}
				],
				"name": "addLiquidity",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "amountA",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountB",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "liquidity",
						"type": "uint256"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "amountIn",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "reserveIn",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "reserveOut",
						"type": "uint256"
					}
				],
				"name": "getAmountOut",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "amountOut",
						"type": "uint256"
					}
				],
				"stateMutability": "pure",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "tokenA",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "tokenB",
						"type": "address"
					}
				],
				"name": "getPrice",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "price",
						"type": "uint256"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "bytes32",
						"name": "",
						"type": "bytes32"
					}
				],
				"name": "pools",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "reserveA",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "reserveB",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "totalLiquidity",
						"type": "uint256"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "tokenA",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "tokenB",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "liquidity",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountAMin",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountBMin",
						"type": "uint256"
					},
					{
						"internalType": "address",
						"name": "to",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "deadline",
						"type": "uint256"
					}
				],
				"name": "removeLiquidity",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "amountA",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountB",
						"type": "uint256"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "amountIn",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "amountOutMin",
						"type": "uint256"
					},
					{
						"internalType": "address[]",
						"name": "path",
						"type": "address[]"
					},
					{
						"internalType": "address",
						"name": "to",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "deadline",
						"type": "uint256"
					}
				],
				"name": "swapExactTokensForTokens",
				"outputs": [
					{
						"internalType": "uint256[]",
						"name": "amounts",
						"type": "uint256[]"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			}
		],
		"devdoc": {
			"details": "Contrato de intercambio descentralizado básico (similar a Uniswap V2) que permite a los usuarios agregar/remover liquidez e intercambiar tokens ERC-20. No depende directamente del protocolo Uniswap; implementa su propia lógica de pool.",
			"errors": {
				"ReentrancyGuardReentrantCall()": [
					{
						"details": "Unauthorized reentrant call."
					}
				]
			},
			"kind": "dev",
			"methods": {
				"addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)": {
					"details": "Permite a los usuarios agregar liquidez a un pool de tokens ERC-20. Si es la primera liquidez, se inicializa el pool. De lo contrario, se calculan las cantidades óptimas para mantener la proporción existente.",
					"params": {
						"amountADesired": "La cantidad deseada de tokenA a depositar.",
						"amountAMin": "La cantidad mínima de tokenA que debe aceptarse (protección contra slippage).",
						"amountBDesired": "La cantidad deseada de tokenB a depositar.",
						"amountBMin": "La cantidad mínima de tokenB que debe aceptarse (protección contra slippage).",
						"deadline": "El tiempo límite para que la transacción sea minada.",
						"to": "La dirección a la que se enviarán los tokens de liquidez (LP tokens).",
						"tokenA": "La dirección del primer token a agregar.",
						"tokenB": "La dirección del segundo token a agregar."
					},
					"returns": {
						"amountA": "La cantidad real de tokenA transferida y utilizada.",
						"amountB": "La cantidad real de tokenB transferida y utilizada.",
						"liquidity": "La cantidad de tokens de liquidez (LP tokens) emitidos."
					}
				},
				"getAmountOut(uint256,uint256,uint256)": {
					"details": "Calcula cuántos tokens de salida se recibirán para una cantidad dada de tokens de entrada, basado en las reservas actuales del pool. Utiliza la fórmula de producto constante (x * y = k) sin aplicar comisiones de swap. amountOut = (amountIn * reserveOut) / (reserveIn + amountIn)",
					"params": {
						"amountIn": "La cantidad del token de entrada.",
						"reserveIn": "La reserva del token de entrada en el pool.",
						"reserveOut": "La reserva del token de salida en el pool."
					},
					"returns": {
						"amountOut": "La cantidad de tokens de salida esperada."
					}
				},
				"getPrice(address,address)": {
					"details": "Devuelve el precio actual de un token en términos de otro. El precio se escala por 1e18 para una mejor precisión. Por ejemplo, si el precio de TokenB en TokenA es 0.5, se retornará 0.5 * 1e18.",
					"params": {
						"tokenA": "La dirección del primer token.",
						"tokenB": "La dirección del segundo token."
					},
					"returns": {
						"price": "El precio de tokenB en términos de tokenA (o viceversa si tokenA > tokenB), escalado por 1e18."
					}
				},
				"removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)": {
					"details": "Permite a los usuarios retirar liquidez de un pool quemando sus tokens de liquidez (LP tokens). Los usuarios reciben una cantidad proporcional de los tokens subyacentes (tokenA y tokenB).",
					"params": {
						"amountAMin": "La cantidad mínima de tokenA que debe recibirse (protección contra slippage).",
						"amountBMin": "La cantidad mínima de tokenB que debe recibirse (protección contra slippage).",
						"deadline": "El tiempo límite para que la transacción sea minada.",
						"liquidity": "La cantidad de tokens de liquidez (LP tokens) a quemar.",
						"to": "La dirección a la que se enviarán los tokens A y B retirados.",
						"tokenA": "La dirección del primer token en el par.",
						"tokenB": "La dirección del segundo token en el par."
					},
					"returns": {
						"amountA": "La cantidad real de tokenA retirada.",
						"amountB": "La cantidad real de tokenB retirada."
					}
				},
				"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)": {
					"details": "Permite a los usuarios intercambiar una cantidad exacta de un token (amountIn) por otro token, con una ruta de un solo salto. El `path` debe contener exactamente dos direcciones: [tokenEntrada, tokenSalida].",
					"params": {
						"amountIn": "La cantidad exacta del token de entrada a intercambiar.",
						"amountOutMin": "La cantidad mínima del token de salida que debe recibirse (protección contra slippage).",
						"deadline": "El tiempo límite para que la transacción sea minada.",
						"path": "Un array con las direcciones de los tokens en la ruta de intercambio (ej: [tokenA, tokenB]).",
						"to": "La dirección a la que se enviará el token de salida."
					},
					"returns": {
						"amounts": "Un array con la cantidad de entrada (amounts[0]) y la cantidad de salida (amounts[1])."
					}
				}
			},
			"title": "SimpleSwap",
			"version": 1
		},
		"userdoc": {
			"kind": "user",
			"methods": {},
			"version": 1
		}
	},
	"settings": {
		"compilationTarget": {
			"TP3/A.sol": "SimpleSwap"
		},
		"evmVersion": "prague",
		"libraries": {},
		"metadata": {
			"bytecodeHash": "ipfs"
		},
		"optimizer": {
			"enabled": false,
			"runs": 200
		},
		"remappings": []
	},
	"sources": {
		"@openzeppelin/contracts/token/ERC20/IERC20.sol": {
			"keccak256": "0xe06a3f08a987af6ad2e1c1e774405d4fe08f1694b67517438b467cecf0da0ef7",
			"license": "MIT",
			"urls": [
				"bzz-raw://df6f0c459663c9858b6cba2cda1d14a7d05a985bed6d2de72bd8e78c25ee79db",
				"dweb:/ipfs/QmeTTxZ7qVk9rjEv2R4CpCwdf8UMCcRqDNMvzNxHc3Fnn9"
			]
		},
		"@openzeppelin/contracts/utils/Panic.sol": {
			"keccak256": "0xf7fe324703a64fc51702311dc51562d5cb1497734f074e4f483bfb6717572d7a",
			"license": "MIT",
			"urls": [
				"bzz-raw://c6a5ff4f9fd8649b7ee20800b7fa387d3465bd77cf20c2d1068cd5c98e1ed57a",
				"dweb:/ipfs/QmVSaVJf9FXFhdYEYeCEfjMVHrxDh5qL4CGkxdMWpQCrqG"
			]
		},
		"@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
			"keccak256": "0x11a5a79827df29e915a12740caf62fe21ebe27c08c9ae3e09abe9ee3ba3866d3",
			"license": "MIT",
			"urls": [
				"bzz-raw://3cf0c69ab827e3251db9ee6a50647d62c90ba580a4d7bbff21f2bea39e7b2f4a",
				"dweb:/ipfs/QmZiKwtKU1SBX4RGfQtY7PZfiapbbu6SZ9vizGQD9UHjRA"
			]
		},
		"@openzeppelin/contracts/utils/math/Math.sol": {
			"keccak256": "0x1225214420c83ebcca88f2ae2b50f053aaa7df7bd684c3e878d334627f2edfc6",
			"license": "MIT",
			"urls": [
				"bzz-raw://6c5fab4970634f9ab9a620983dc1c8a30153981a0b1a521666e269d0a11399d3",
				"dweb:/ipfs/QmVRnBC575MESGkEHndjujtR7qub2FzU9RWy9eKLp4hPZB"
			]
		},
		"@openzeppelin/contracts/utils/math/SafeCast.sol": {
			"keccak256": "0x195533c86d0ef72bcc06456a4f66a9b941f38eb403739b00f21fd7c1abd1ae54",
			"license": "MIT",
			"urls": [
				"bzz-raw://b1d578337048cad08c1c03041cca5978eff5428aa130c781b271ad9e5566e1f8",
				"dweb:/ipfs/QmPFKL2r9CBsMwmUqqdcFPfHZB2qcs9g1HDrPxzWSxomvy"
			]
		},
		"TP3/A.sol": {
			"keccak256": "0x45594f8e02b157f09d53b7388cac8d9370814b40c53f2c1c05d90231385b51ca",
			"license": "MIT",
			"urls": [
				"bzz-raw://216140e37290e530f9cb48ce1813ba1b2f67ed6827d2f8c8ca900991becfb91c",
				"dweb:/ipfs/QmQc8b7HdUrCJYmBfJDv1K6XhHMqyX839yVdJk9huXMwAC"
			]
		}
	},
	"version": 1
}